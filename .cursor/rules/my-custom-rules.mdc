---
description: "Quy tắc phát triển dự án Web Đọc Truyện Tiệm Truyện Mèo Béo"
globs:
  - "**/*.java"
  - "**/*.kt"
  - "**/*.md"
alwaysApply: true
---

# CURSOR INSTRUCTION – WEB ĐỌC TRUYỆN

## 🔁 Ngôn ngữ mặc định:

- Tất cả câu trả lời, hướng dẫn, code và giải thích đều **bằng tiếng Việt**.
- Nếu người dùng dùng tiếng Anh hoặc yêu cầu xuất code tiếng Anh thì mới chuyển.

---

## 🧾 Khi yêu cầu có nội dung dài:

- **Không trả lời 1 cục dài**.
- Phân tích yêu cầu thành **TODO list cụ thể**, ví dụ:
  - Bước 1: Thiết kế API
  - Bước 2: Viết controller
  - Bước 3: Tạo entity và service
- Mỗi bước trả lời riêng, **giữ tiến độ rõ ràng**, tránh nhảy cóc.

---

## 🛠️ Đối với Java Spring Boot:

- **KHÔNG sử dụng `@Autowired` field injection.**
  - ✅ Dùng constructor injection cho mọi service, repository.
- Ưu tiên **`@Service`, `@Repository`, `@Component` rõ ràng**, không nhồi logic vào controller.
- Tuân thủ mô hình **Clean Architecture** hoặc **Layered Architecture**:
  - `Controller` → `Service` → `Repository`
- Mỗi controller/service không nên dài quá 300 dòng.
- Không hard-code string như role hay status: nên dùng `enum` hoặc `constant`.

---

## 🧹 Code sạch và maintainable:

- Format code chuẩn theo Java conventions (CamelCase, PascalCase…).
- Không dùng biến đặt tên `a`, `b`, `temp` – tất cả biến phải có ý nghĩa.
- Comment khi cần, KHÔNG comment thừa.
- Nếu có đoạn code phức tạp → giải thích rõ trong comment hoặc docstring.
- Ở controller comment để biết API dùng để làm gì .
- Ưu tiên viết code **đọc được dễ hơn là viết ngắn**.

---

## 📊 JPA – Query – Index:

- Khi làm việc với các bảng lớn như `chapters`, `stories`, `reading_history`, `chapter_unlocks`…:
  - ✅ Luôn xác định rõ truy vấn chính để tạo **index phù hợp** trong PostgreSQL.
- Nếu dùng JPA filter như:
  - Lọc chương theo `story_slug`, `chapter_number` → dùng composite index `(story_id, chapter_number)`
  - Kiểm tra unlock chương → index `(user_id, chapter_id)`
  - Lấy truyện theo `slug` → index `slug` UNIQUE
- Với truy vấn phức tạp, đừng lạm dụng `findBy…` mà dùng `@Query` hoặc `QueryDSL` để:
  - JOIN chính xác
  - FETCH để tránh lazy loading chậm
- Nếu phân trang → bắt buộc dùng `Pageable`
- Nếu cần tìm kiếm nâng cao (keyword, tag, tác giả,…) → index FULLTEXT hoặc ElasticSearch (nếu mở rộng)
- Viết câu truy vấn sao cho tối ưu với PostgreSQL nhất.

## 🚀 Performance:

- Khi xử lý nhiều dữ liệu:
  - ✅ Dùng `JOIN` thay vì query từng bảng.
  - ✅ Sử dụng `@Query` với `JOIN FETCH` nếu cần tránh lazy loading quá nhiều.
- Với API có phân trang: Luôn sử dụng `Pageable`, trả kết quả có:
  - `content`
  - `page`
  - `totalPages`
  - `totalElements`
- Với các bảng lớn: Chỉ lấy những field cần thiết → nên tạo DTO riêng.

---

## 🧠 Trí tuệ và tự động hóa:

- Khi người dùng cung cấp yêu cầu phức tạp:
  - Phân tích mục tiêu và chia thành các phần rõ ràng.
  - Gợi ý nếu có giải pháp tối ưu hơn.
- Luôn đặt câu hỏi ngược nếu yêu cầu không rõ.

---

## 💡 Tips xử lý truyện:

- Với các bảng như `stories`, `chapters`, `reading_history`:
  - Dùng index thông minh (composite key, slug, chapter_number…).
- Dùng Redis cache để giảm tải khi lấy truyện hot, đề cử nhiều.
- Luôn log lại hành động nạp tiền, đề cử, đọc truyện… để audit.

---

## 🎯 Đảm bảo chuyên nghiệp:

- Mọi code đều phải:
  - Có unit test nếu phức tạp.
  - Có exception handling rõ ràng (`@ControllerAdvice` nếu có thể).
  - Gắn log cho các thao tác quan trọng (login, thanh toán, unlock…).
- Khi query custom:
  - Nên dùng `JPQL` hoặc `@Query`, không viết lỏm bỏm trong code.
- Luôn suy nghĩ về khả năng **scaling**, phân quyền, và bảo trì lâu dài.

---

## 📦 Tích hợp:

- Nếu dùng Redis, JWT, Paypal… thì cần config rõ, comment cụ thể từng đoạn.
- Luôn tạo `application.yaml` mẫu để dễ setup môi trường.

---

## 🧷 Quản lý Role:

- 3 loại tài khoản:
  - `ADMIN`: Quản trị, duyệt truyện, người dùng
  - `UPLOADER`: Người đăng truyện
  - `USER`: Người đọc truyện bình thường

---

## 📜 Phản hồi người dùng:

- Khi trả lời user:
  - Luôn giữ thái độ thân thiện, thẳng thắn.
  - Không nịnh bợ.
  - Nếu có lỗi, gợi ý sửa rõ ràng.

---

## 👀 Đọc context và mã nguồn hiện tại

- Trước khi tạo hoặc chỉnh sửa file, **luôn phải đọc, phân tích kỹ toàn bộ mã nguồn hiện tại của project**.
- Nếu phát hiện chức năng đã tồn tại, chỉ update đúng logic hoặc refactor, **KHÔNG được tạo file mới trùng chức năng**.
- Khi thực hiện các bước (TODO) cần ưu tiên **tái sử dụng code cũ**, tránh duplicate logic.
- Nếu có nghi ngờ về file/class đã tồn tại hay chưa, hãy hỏi lại user hoặc tự động kiểm tra.

## ⛔ Quy tắc không tự ý tạo file

- **KHÔNG tự động sinh thêm bất kỳ file nào ngoài các file đúng với chức năng user yêu cầu, đặc biệt là các file ví dụ, template, script, test không cần thiết.**
- **KHÔNG tự động tạo các class, interface, entity, config, hoặc bất kỳ resource nào nếu trong mã nguồn đã có sẵn hoặc user không yêu cầu bổ sung.**
- **TRƯỚC KHI tạo file mới, phải kiểm tra kỹ mã nguồn hiện tại, tránh tạo trùng tên, trùng chức năng hoặc sinh file không cần thiết.**
- **CHỈ tạo mới nếu chắc chắn chưa tồn tại, hoặc có thay đổi lớn được yêu cầu rõ ràng. Nếu phân vân nên hỏi lại user.**
- Nếu user yêu cầu sửa/chỉnh sửa thì phải chỉnh trực tiếp file hiện có, **KHÔNG tạo file mới thay thế**.
- Không tạo file `example`, `sample`, `test`, `mock`, `data.sql`, hoặc các file mang tính chất hướng dẫn demo, trừ khi có chỉ thị rõ.
- Không tự sinh file service, repository, entity, dto nếu mã nguồn đã có class tương ứng – **luôn ưu tiên update file hiện có**.

- Không tự động tạo file README.md để hướng dẫn sử dụng.
- Và không tự tạo những file không liên quan về ví dụ sử dụng hay gì.
- Không sử dụng Emoji trong mã nguồn trừ khi có yêu cầu.

## 📂 Quy tắc trả về file và cấu trúc

- Khi trả về nhiều file, **chỉ trả đúng và đủ file liên quan trực tiếp đến tính năng được yêu cầu**.
- Không tự chia nhỏ hoặc tách file ra nếu không có lý do kỹ thuật rõ ràng hoặc không có chỉ đạo từ user.
- Nếu sửa một logic nhỏ hoặc API, **chỉ trả file liên quan, không "bonus" thêm file khác không được yêu cầu**.

## Yêu cầu viết Commit

- Trả về người dùng commit bằng tiếng anh và chuẩn cấu trúc sao cho gọn đúng yêu cầu và thống nhất.
